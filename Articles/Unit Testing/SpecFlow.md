---
title: IEnumerable в SpecFlow или первое знакомство
---

 

Доброго времени суток. В этой статье я хотел бы поделится своим опытом работы со
SpecFlow. В просторах всемирной паутины можно найти разные мнения по поводу этой
технологии. Но так как SpecFlow считается одним из инструментов технологии BDD,
все споры о его применении сводятся именно к сравнению TDD и BDD, и про это тоже
можно много всего прочитать. Мне лично понравилось одно определение: "TDD —
делать вещи правильно. BDD — делать правильные вещи. Они не взаимозаменяемы.",
согласитесь очень красиво, понятно и лаконично. Однако, я решил использовать
SpecFlow не углубляясь в основы каких либо технологий или потому что кто то
считает такой подход правильным или хорошим тоном, а просто потому, что я
столкнулся с ситуацией где просто не возможно написать простые и понятные юнит
тесты. То есть написать тесты можно, но что конкретно тестируется и как
абсолютно не понятно. Тут и пришёл на помощь SpecFlow, что бы как то описать
тест более или менее человеческим языком.

О том как я это пытался сделать и с какими сложностями столкнулся я бы и хотел
написать.

Я нашел огромное количество пошаговых инструкций работы со SpecFlow, включая
примеры и видеообзоры. Оказалось использовать этот инструмент не сложно и я бы
сказал приятно, но все таки я столкнулся с некоторыми проблемами. Дело в том,
что в моем проекте на вход идут множество списков элементов с достаточно сложной
структурой. Далее попробую описать на примере, более простом, но достаточно
наглядном.

Допустим нам нужно протестировать функцию фильтрации точек. В данном примере не
важно по какому ринципу, но допустим: необходимо найти точки которые находятся
внутри круга определенного радиуса. Понятное дело нам необходимо дать на вход
список этих самых точек, и тут мы сталкиваемся со некоторой проблемой и
несколькими вариантами решения.

 

### Вариант первый

 

Просто добавлять по одному.

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Scenario: Add two point
    Given Add point with X = 0 and Y = 1

    And Add point with X = 3 and Y = -2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Этот метод прост и понятен, но если нам нужно обработать большое количество
точек, да еще и для нескольких сценариев, то придется долгими бессмысленными
вечерами копипастить, проклиная данную технологию. Исходя из этого я решил
поискать как же все-таки передавать списки параметрами и нашел второй вариант.

 

### Вариант второй

 

Некоторые пользователи технологии решают эту ситуацию записывая значения
коллекций через запятую или какой-нибудь другой разделитель. К примеру:
"1,2,3,4". Удобно, но поскольку такой формат записи не предусмотрен, на вход нам
и приходит строка: "1,2,3,4". Единственное что мы можем сделать, это написать
парсер:

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[StepArgumentTransformation(@"((?:.,\d+)*(?:.+))")]
public static IEnumerable<int> ListIntTransform(string ints)
{
    return ints.Split(new[] { ',' }).Select(int.Parse);
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

И тогда в свой метод мы уже получим список интов. Лично мне кажется этот способ
несколько нелепым, но у него есть большой плюс в случаи, если нам нужно
протестировать несколько наборов данных для одного сценария.

В таком случаи мы совершенно спокойно можем использовать таблицу Examples. К
примеру:

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Scenario Outline: Add numbers
    Given I have entered <values> into the calculator

Examples:
| values    |
| 1,2,3,4,5 |
| 2,6,7,40, |
| 2,9,50    |
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

Однако, в нашем случаи с точками, запись строки будет выглядить примерно так:
"(0,1),(3,-2),(4,5),(8,0)" ну или как кому удобно, тут нас никто не
ограничивает. Конечно, пока выглядит не так страшно, но если передавать списки с
более сложными обьектами, то получаеться запись просто не читабильна.

В связи с этим я решил поискать еще варианты решения вопроса и пришел к 3-му
варианту.

 

### Вариант третий

 

Мы просто записываем список в ввиде таблицы полей

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Scenario: Paste numbers
    Given I have entered points
    
    | x | y |
    | 1 | 2 |
    | 3 | 4 |    
    | 5 | 2 |    
    | 6 | 0 |
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

А потом просто получаем эти данные в нашем методе:

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Given ("I have entered points")]
public void x(Table table)
{
    var points = table.CreateSet <Point>();
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

На мой взгляд, это лучший вариант работы со списками, он также рекомендуется и в
документации SpecFlow. Но использовать один сценарий для разных наборов данных,
как во втором варианте, с помощью такого решения нельзя (а очень бы хотелось),
ну или я не нашел.

 

### Выводы

 

Не смотря на то что я так и не нашел подходящего для себя решения проблемы
работы со списками, я рад что решил тестировать свой проект использую SpecFlow.

И хоть и времени на написание подобных тестов уходит малость больше, но хотя бы
в результате получаются понятные и читабельные тесты.
